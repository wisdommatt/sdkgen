// Code generated by sdkgen; DO NOT EDIT.

package client

import (
    "time"
    "net/http"
    "io"
    "encoding/json"
    "encoding/xml"
    "bytes"
    "context"
    "fmt"
)

{{ $schema := . }}

{{ range $name, $definition := $schema.Definitions }}
{{ if eq $definition.Type "object" }}

type {{ toCamelCase $name }} struct {
    {{ range $propName, $prop := $definition.Properties }} {{ toCamelCase $propName }} {{ extractTypeName $schema $name $prop }} `json:"{{ $propName }}"` 
    {{ end }}
}

{{ else }}

type {{ toCamelCase $name }} {{ extractTypeName $schema $name $definition }}

{{ end }}
{{ end }}

{{ range $name, $response := $schema.Responses }}
{{ if eq $response.Schema.Type "object" }}

type {{ toCamelCase $name }} struct {
    {{ range $propName, $prop := $response.Schema.Properties}} {{ toCamelCase $propName }} {{ extractTypeName $schema $name $prop }} `json:"{{ $propName }}"` 
    {{ end }}
}

{{ end }}
{{ end }}


type ClientConfiguration struct {
    BaseURL string
	DefaultHTTPHeaders map[string]string
}

type APIClient struct {
    cfg ClientConfiguration
    {{ range $apiName, $_ := $schema.ApiPathsMap }} {{ toCamelCase $apiName }} *{{ toCamelCase $apiName }}API
    {{ end }}
}

// NewAPIClient creates a new API client.
func NewAPIClient(cfg ClientConfiguration) *APIClient {
    if len(cfg.DefaultHTTPHeaders) == 0 {
        cfg.DefaultHTTPHeaders = make(map[string]string)
    }
    client := &APIClient{
        cfg: cfg,
        {{ range $apiName, $_ := $schema.ApiPathsMap }} {{ toCamelCase $apiName }}: &{{ toCamelCase $apiName }}API{},
        {{ end }}
    }

    {{ range $apiName, $_ := $schema.ApiPathsMap }} client.{{ toCamelCase $apiName }}.client = client
    {{ end }}
    return client
}

func (c *APIClient) makeHttpRequest(ctx context.Context, method, path string, requestBody, decodeTo interface{}) (*http.Response, error) {
	var body io.Reader = nil
    if requestBody != nil {
        requestBodyJSON, err := json.Marshal(requestBody)
        if err != nil {
            return nil, err
        }
        body = bytes.NewBuffer(requestBodyJSON)
    }
	req, err := http.NewRequest(method, fmt.Sprintf("%s%s", c.cfg.BaseURL, path), body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("Accept", "application/json")
	req.Header.Set("Content-Type", "application/json")
    for key, value := range c.cfg.DefaultHTTPHeaders {
        req.Header.Set(key, value)
    }
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	err = json.NewDecoder(resp.Body).Decode(decodeTo)
	if err != nil {
		return nil, err
	}
	return resp, err
}

func (c *APIClient) decodeResponse(body io.Reader, contentType string, v interface{}) error {
    if strings.EqualFold(contentType, "application/json") {
        err := json.NewDecoder(body).Decode(v)
        return err
    } else if strings.EqualFold(contentType, "application/xml") {
        err := xml.NewDecoder(body).Decode(v)
        return err
    }
    return fmt.Errorf("invalid response content type: %s", contentType)
}

{{ range $apiName, $apiInfo := $schema.ApiPathsMap }}

type {{ toCamelCase $apiName }}API struct {
    client *APIClient
}

{{ range $path, $pathInfoMap := $apiInfo }}
{{ range $httpMethod, $pathInfo := $pathInfoMap }}

{{ $input := print ",input " (extractTypeName $schema "" (pathParameterToProperty $pathInfo.Parameters)) }}
{{ if eq $input ",input " }}
{{ $input = "" }}
{{ end }}

{{ $methodName := toCamelCase $pathInfo.OperationID }}
{{ $responseType := print $methodName "ApiResponse"}}

type {{ $responseType }} {{ extractResponseType $schema $responseType $pathInfo.Responses }}

func (s *{{ toCamelCase $apiName }}API) {{ $methodName }}(ctx context.Context {{ $input }}) (*{{ $responseType }}, error) {
    var response {{ $responseType }}
    {{ if ne $input "" }} requestBody := input {{ else }} var requestBody interface{} {{ end }}
    httpResponse, err := s.client.makeHttpRequest(ctx, "{{ toUpperCase $httpMethod }}", "{{ $path }}", requestBody, &response)
	if err != nil {
		return nil, err
	}
    defer httpResponse.Body.Close()
    contentType := httpResponse.Header.Get("Content-Type")
    err = s.client.decodeResponse(httpResponse.Body, contentType, &response)
	if err != nil {
        return nil, err
	}
    return &response, nil
}

{{ end }}
{{ end }}
{{ end }}

// Code generated by sdkgen; DO NOT EDIT.

package client

import (
    "time"
    "net/http"
    "io"
    "encoding/json"
    "encoding/xml"
    "bytes"
    "context"
    "fmt"
)

{{ $schema := . }}

{{ range $name, $definition := $schema.Definitions }}
{{ if eq $definition.Type "object" }}

type {{ toCamelCase $name }} struct {
    {{ range $propName, $prop := $definition.Properties }} {{ toCamelCase $propName }} {{ (pointerPrefix $definition $propName (extractTypeName $schema $prop)) }} `json:"{{ $propName }},omitempty"` 
    {{ end }}
}

{{ else }}

type {{ toCamelCase $name }} {{ extractTypeName $schema $definition }}

{{ end }}
{{ end }}

{{ range $name, $response := $schema.Responses }}
{{ if eq $response.Schema.Type "object" }}

type {{ toCamelCase $name }} struct {
    {{ range $propName, $prop := $response.Schema.Properties}} {{ toCamelCase $propName }} {{ extractTypeName $schema $prop }} `json:"{{ $propName }}"` 
    {{ end }}
}

{{ end }}
{{ end }}


type ClientConfiguration struct {
    BaseURL string
	DefaultHTTPHeaders map[string]string
}

type APIClient struct {
    cfg ClientConfiguration
    {{ range $apiName, $_ := $schema.ApiPathsMap }} {{ toCamelCase $apiName }} *{{ toCamelCase $apiName }}API
    {{ end }}
}

// NewAPIClient creates a new API client.
func NewAPIClient(cfg ClientConfiguration) *APIClient {
    if len(cfg.DefaultHTTPHeaders) == 0 {
        cfg.DefaultHTTPHeaders = make(map[string]string)
    }
    client := &APIClient{
        cfg: cfg,
        {{ range $apiName, $_ := $schema.ApiPathsMap }} {{ toCamelCase $apiName }}: &{{ toCamelCase $apiName }}API{},
        {{ end }}
    }

    {{ range $apiName, $_ := $schema.ApiPathsMap }} client.{{ toCamelCase $apiName }}.client = client
    {{ end }}
    return client
}

func (c *APIClient) makeHttpRequest(ctx context.Context, method, path string, accepts, contentTypes []string, requestBody, decodeTo interface{}) (*http.Response, error) {
	var body io.Reader = nil
    if requestBody != nil {
        requestBodyJSON, err := json.Marshal(requestBody)
        if err != nil {
            return nil, err
        }
        body = bytes.NewBuffer(requestBodyJSON)
    }
	req, err := http.NewRequest(method, fmt.Sprintf("%s%s", c.cfg.BaseURL, path), body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
    if len(accepts) > 0 {
        req.Header.Set("Accept", c.extractContentType(accepts))
    }
    if len(contentTypes) > 0 {
        req.Header.Set("Content-Type", c.extractContentType(contentTypes))
    }
    for key, value := range c.cfg.DefaultHTTPHeaders {
        req.Header.Set(key, value)
    }
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
    contentType := resp.Header.Get("Content-Type")
    err = c.decodeResponse(resp.Body, contentType, decodeTo)
	if err != nil {
        return nil, err
	}
	return resp, err
}

func (c *APIClient) extractContentType(contentTypes []string) string {
    if len(contentTypes) == 0 {
        return ""
    }
    for _, contentType := range contentTypes {
        contentType = strings.ToLower(contentType)
        if strings.Contains(contentType, "application/json") {
            return contentType
        }
    }
    return strings.Join(contentTypes, ",")
}

func (c *APIClient) decodeResponse(body io.Reader, contentType string, v interface{}) error {
    contentType = strings.ToLower(contentType)
    if strings.Contains(contentType, "application/xml") {
        err := xml.NewDecoder(body).Decode(v)
        return err
    } 
    return json.NewDecoder(body).Decode(v)
}

{{ range $apiName, $apiInfo := $schema.ApiPathsMap }}

type {{ toCamelCase $apiName }}API struct {
    client *APIClient
}

{{ range $path, $pathInfoMap := $apiInfo }}
{{ range $httpMethod, $pathInfo := $pathInfoMap }}

{{ $input := print ",input " (extractTypeName $schema (pathParameterToProperty $pathInfo.Parameters)) }}
{{ if eq $input ",input " }}
{{ $input = "" }}
{{ end }}

{{ $methodName := toCamelCase $pathInfo.OperationID }}
{{ $responseType := print $methodName "ApiResponse"}}

type {{ $responseType }} {{ extractResponseType $schema $responseType $pathInfo.Responses }}

func (s *{{ toCamelCase $apiName }}API) {{ $methodName }}(ctx context.Context {{ $input }}) (*{{ $responseType }}, error) {
    var response {{ $responseType }}
    {{ if ne $input "" }} requestBody := input {{ else }} var requestBody interface{} {{ end }}
    accepts := []string{ {{ range $contentType := $pathInfo.Produces }} "{{ $contentType }}", {{ end }} }
    consumes := []string{ {{ range $contentType := $pathInfo.Consumes }} "{{ $contentType }}", {{ end }} }
    _, err := s.client.makeHttpRequest(ctx, "{{ toUpperCase $httpMethod }}", "{{ $path }}", accepts, consumes, requestBody, &response)
	if err != nil {
		return nil, err
	}
    return &response, nil
}

{{ end }}
{{ end }}
{{ end }}

{{/* TODO(wisdommatt): implement logic for multipart-formdata / file uploads */}}
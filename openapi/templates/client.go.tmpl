// Code generated by sdkgen; DO NOT EDIT.

package client

import (
    "time"
    "net/http"
    "io"
    "encoding/json"
    "bytes"
    "context"
    "fmt"
)

{{ $schema := . }}

{{ range $name, $definition := $schema.Definitions }}
{{ if eq $definition.Type "object" }}

type {{ toCamelCase $name }} struct {
    {{ range $propName, $prop := $definition.Properties }} {{ toCamelCase $propName }} {{ extractTypeName $schema $name $prop }} `json:"{{ $propName }}"` 
    {{ end }}
}

{{ else }}

type {{ toCamelCase $name }} {{ extractTypeName $schema $name (definitionToProperty $definition) }}

{{ end }}
{{ end }}

{{ range $name, $response := $schema.Responses }}
{{ if eq $response.Schema.Type "object" }}

type {{ toCamelCase $name }} struct {
    {{ range $propName, $prop := $response.Schema.Properties}} {{ toCamelCase $propName }} {{ extractTypeName $schema $name $prop }} `json:"{{ $propName }}"` 
    {{ end }}
}

{{ end }}
{{ end }}


type ClientConfiguration struct {
    BaseURL string
	DefaultHTTPHeaders map[string]string
}

type APIClient struct {
    cfg ClientConfiguration
    {{ range $apiName, $_ := $schema.ApiPathsMap }} {{ toCamelCase $apiName }} *{{ toCamelCase $apiName }}API
    {{ end }}
}

// NewAPIClient creates a new API client.
func NewAPIClient(cfg ClientConfiguration) *APIClient {
    if len(cfg.DefaultHTTPHeaders) == 0 {
        cfg.DefaultHTTPHeaders = make(map[string]string)
    }
    client := &APIClient{
        cfg: cfg,
        {{ range $apiName, $_ := $schema.ApiPathsMap }} {{ toCamelCase $apiName }}: &{{ toCamelCase $apiName }}API{},
        {{ end }}
    }

    {{ range $apiName, $_ := $schema.ApiPathsMap }} client.{{ toCamelCase $apiName }}.client = client
    {{ end }}
    return client
}

func (c *APIClient) makeHttpRequest(ctx context.Context, method, path string, requestBody, decodeTo interface{}) (*http.Response, error) {
	var body io.Reader = nil
    if requestBody != nil {
        requestBodyJSON, err := json.Marshal(requestBody)
        if err != nil {
            return nil, err
        }
        body = bytes.NewBuffer(requestBodyJSON)
    }
	req, err := http.NewRequest(method, fmt.Sprintf("%s%s", c.cfg.BaseURL, path), body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("Accept", "application/json")
	req.Header.Set("Content-Type", "application/json")
    for key, value := range c.cfg.DefaultHTTPHeaders {
        req.Header.Set(key, value)
    }
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	err = json.NewDecoder(resp.Body).Decode(decodeTo)
	if err != nil {
		return nil, err
	}
	return resp, err
}


{{ range $apiName, $apiInfo := $schema.ApiPathsMap }}

type {{ toCamelCase $apiName }}API struct {
    client *APIClient
}

{{ range $path, $pathInfoMap := $apiInfo }}
{{ range $httpMethod, $pathInfo := $pathInfoMap }}

{{ $input := print ",input " (extractTypeName $schema "" (pathParameterToProperty $pathInfo.Parameters)) }}
{{ if eq $input ",input " }}
{{ $input = "" }}
{{ end }}

func (s *{{ toCamelCase $apiName }}API) {{ toCamelCase $pathInfo.OperationID }}(ctx context.Context {{ $input }}) error {
    panic("unimplemented")
}

{{ end }}
{{ end }}
{{ end }}
